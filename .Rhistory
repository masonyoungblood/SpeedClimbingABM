load("local/w/models/improve_rate_m_model.RData")
improve_rate_m_model <- model
rm(model)
obs_stats
unlist(obs_stats)
unlist(obs_stats[-1])
t(matrix(unlist(obs_stats[-1])))
data.frame(t(matrix(unlist(obs_stats[-1]))))
predict(preprocessing(data.frame(t(matrix(unlist(obs_stats[-1])))))
)
predict(preprocessing, (data.frame(t(matrix(unlist(obs_stats[-1])))))
)
predict(preprocessing, (data.frame(t(matrix(unlist(obs_stats[-1]))))))
obs_stats <- predict(preprocessing, (data.frame(t(matrix(unlist(obs_stats[-1]))))))
predict(innov_prob_model,  obs_stats)
predict(innov_prob_model, obs_stats, type = "response")
inv_logit(predict(innov_prob_model, obs_stats, type = "response"), c(0, 1))
inv_logit(predict(learn_prob_model, obs_stats, type = "response"), c(0, 1))
inv_logit(predict(innov_prob_model, obs_stats, type = "response"), c(0, 1))
inv_logit(predict(innov_prob_model, obs_stats, type = "response"), c(0, 1))
inv_logit(predict(innov_prob_model, obs_stats, type = "response"), c(0, 1))
inv_logit(predict(innov_prob_model, obs_stats, type = "response"), c(0, 1))
inv_logit(predict(innov_prob_model, obs_stats, type = "response"), c(0, 1))
inv_logit(predict(innov_prob_model, obs_stats, type = "response"), c(0, 1))
inv_logit(predict(innov_prob_model, obs_stats, type = "response"), c(0, 1))
inv_logit(predict(innov_prob_model, obs_stats, type = "response"), c(0, 1))
inv_logit(predict(innov_prob_model, obs_stats, type = "response"), c(0, 1))
inv_logit(predict(innov_prob_model, obs_stats, type = "response"), c(0, 1))
inv_logit(predict(innov_prob_model, obs_stats, type = "response"), c(0, 1))
inv_logit(predict(innov_prob_model, obs_stats, type = "response"), c(0, 1))
inv_logit(predict(innov_prob_model, obs_stats, type = "response"), c(0, 1))
inv_logit(predict(innov_prob_model, obs_stats, type = "response"), c(0, 1))
inv_logit(predict(innov_prob_model, obs_stats, type = "response"), c(0, 1))
inv_logit(predict(innov_prob_model, obs_stats, type = "response"), c(0, 1))
inv_logit(predict(innov_prob_model, obs_stats, type = "response"), c(0, 1))
inv_logit(predict(innov_prob_model, obs_stats, type = "response"), c(0, 1))
inv_logit(predict(innov_prob_model, obs_stats, type = "response"), c(0, 1))
inv_logit(predict(innov_prob_model, obs_stats, type = "response"), c(0, 1))
inv_logit(predict(innov_prob_model, obs_stats, type = "response"), c(0, 1))
inv_logit(predict(innov_prob_model, obs_stats, type = "response"), c(0, 1))
inv_logit(predict(innov_prob_model, obs_stats, type = "response"), c(0, 1))
inv_logit(predict(innov_prob_model, obs_stats, type = "response"), c(0, 1))
inv_logit(predict(innov_prob_model, obs_stats, type = "response"), c(0, 1))
sapply(1:100, function(x){inv_logit(predict(innov_prob_model, obs_stats, type = "response"), c(0, 1)))})
sapply(1:100, function(x){inv_logit(predict(innov_prob_model, obs_stats, type = "response"), c(0, 1))})
innov_preds <- sapply(1:100, function(x){inv_logit(predict(innov_prob_model, obs_stats, type = "response"), c(0, 1))})
plot(density(innov_preds))
innov_prob_pred <- sapply(1:100, function(x){inv_logit(predict(innov_prob_model, obs_stats, type = "response"), c(0, 1))})
learn_prob_pred <- sapply(1:100, function(x){inv_logit(predict(innov_prob_model, obs_stats, type = "response"), c(0, 1))})
n_top_pred <- sapply(1:100, function(x){inv_logit(predict(innov_prob_model, obs_stats, type = "response"), c(0, 1))})
improve_rate_m_pred <- sapply(1:100, function(x){inv_logit(predict(innov_prob_model, obs_stats, type = "response"), c(1, 3))})
plot(density(learn_prob_pred))
plot(density(n_top_pred))
plot(density(improve_rate_m_pred))
innov_prob_pred <- sapply(1:100, function(x){inv_logit(predict(innov_prob_model, obs_stats, type = "response"), c(0, 1))})
learn_prob_pred <- sapply(1:100, function(x){inv_logit(predict(learn_prob_model, obs_stats, type = "response"), c(0, 1))})
n_top_pred <- sapply(1:100, function(x){inv_logit(predict(n_top_model, obs_stats, type = "response"), c(0, 1))})
improve_rate_m_pred <- sapply(1:100, function(x){inv_logit(predict(improve_rate_m_model, obs_stats, type = "response"), c(1, 3))})
plot(density(n_top_pred))
plot(density(learn_prob_pred))
plot(density(innov_prob_pred))
plot(density(n_top_pred))
plot(density(improve_rate_m_pred))
innov_prob_pred <- parallel::mclapply(1:100, function(x){inv_logit(predict(innov_prob_model, obs_stats, type = "response"), c(0, 1))}, mc.cores = 7)
#set seed
set.seed(12345)
#get 1000 predictions for each value
innov_prob_pred <- sapply(1:1000, function(x){inv_logit(predict(innov_prob_model, obs_stats, type = "response"), c(0, 1))})
learn_prob_pred <- sapply(1:1000, function(x){inv_logit(predict(learn_prob_model, obs_stats, type = "response"), c(0, 1))})
n_top_pred <- sapply(1:1000, function(x){inv_logit(predict(n_top_model, obs_stats, type = "response"), c(0, 1))})
improve_rate_m_pred <- sapply(1:1000, function(x){inv_logit(predict(improve_rate_m_model, obs_stats, type = "response"), c(1, 3))})
plot(density(innov_prob_pred))
plot(density(learn_prob_pred))
plot(density(n_top_pred))
plot(density(improve_rate_m_pred))
#create and save data frame of predictions
predictions <- data.frame(innov_prob = innov_prob_pred, learn_prob = learn_prob_pred, n_top = n_top_pred, improve_rate_m = improve_rate_m_pred)
predictions
save(predictions, file = "local/w/predictions.RData")
#set working directory, load data, source code
setwd("/Users/masonyoungblood/Documents/Work/Summer_2021/Speed Climbing/SpeedClimbingABM")
load("data.RData")
grid <- read.csv("grid.csv")/1000
source("SpeedClimbingABM.R")
#load packages
library(cito)
library(caret)
#logit and inverse logit functions with bounds
logit <- function(p, bounds){
norm_p <- (p - bounds[1])/(bounds[2] - bounds[1])
return(log(norm_p/(1-norm_p)))
}
inv_logit <- function(l, bounds){
inv_l <- exp(l)/(1+exp(l))
return((inv_l*(bounds[2] - bounds[1])) + bounds[1])
}
#subset data by gender
data <- data[which(data$gender == "M"), ]
#get all unique climbers
uniq_climbers <- unique(data$athlete)
#separate continuous sequences of years
seqs <- lapply(uniq_climbers, function(x){split(data$year[which(data$athlete == x)], cumsum(seq_along(data$year[which(data$athlete == x)]) %in% (which(diff(data$year[which(data$athlete == x)]) > 1) + 1)))})
#for each unique climber, iterate through their sequences, and and extract their ID, start year, end year, and time in start year (separate row per sequence)
pop_data <- data.table::data.table(do.call(rbind, lapply(1:length(uniq_climbers), function(i){
t(sapply(1:length(seqs[[i]]), function(j){
c(uniq_climbers[i], min(unlist(seqs[[i]][j])), max(unlist(seqs[[i]][j])), data$time[which(data$athlete == uniq_climbers[i] & data$year == min(unlist(seqs[[i]][j])))])
}))
})))
colnames(pop_data) <- c("ID", "start", "end", "time")
pop_data
#get years
years <- sort(unique(data$year))
#get population sizes
n <- unlist(lapply(1:length(years), function(x){nrow(data[which(data$year == years[x]), ])}))
#load it
load("local/m/sum_stats.RData")
#https://topepo.github.io/caret/pre-processing.html
preprocessing <- preProcess(data.frame(sum_stats), method = c("center", "scale"))
#load models
load("local/m/models/innov_prob_model.RData")
innov_prob_model <- model
rm(model)
load("local/m/models/learn_prob_model.RData")
learn_prob_model <- model
rm(model)
load("local/m/models/n_top_model.RData")
n_top_model <- model
rm(model)
load("local/m/models/improve_rate_m_model.RData")
improve_rate_m_model <- model
rm(model)
#get observed summary statistics
obs_stats <- lapply(years, function(x){sort(data$time[which(data$year == x)])})
obs_stats <- predict(preprocessing, (data.frame(t(matrix(unlist(obs_stats[-1]))))))
#set seed
set.seed(12345)
#get 1000 predictions for each value
innov_prob_pred <- sapply(1:1000, function(x){inv_logit(predict(innov_prob_model, obs_stats, type = "response"), c(0, 1))})
learn_prob_pred <- sapply(1:1000, function(x){inv_logit(predict(learn_prob_model, obs_stats, type = "response"), c(0, 1))})
n_top_pred <- sapply(1:1000, function(x){inv_logit(predict(n_top_model, obs_stats, type = "response"), c(0, 1))})
improve_rate_m_pred <- sapply(1:1000, function(x){inv_logit(predict(improve_rate_m_model, obs_stats, type = "response"), c(1, 3))})
#create and save data frame of predictions
predictions <- data.frame(innov_prob = innov_prob_pred, learn_prob = learn_prob_pred, n_top = n_top_pred, improve_rate_m = improve_rate_m_pred)
save(predictions, file = "local/m/predictions.RData")
plot(density(innov_prob_pred))
plot(density(learn_prob_pred))
plot(density(n_top_pred))
plot(density(improve_rate_m))
plot(density(improve_rate_m_pred))
gof
#set working directory, load data, source code
setwd("/Users/masonyoungblood/Documents/Work/Summer_2021/Speed Climbing/SpeedClimbingABM")
load("data.RData")
grid <- read.csv("grid.csv")/1000
source("SpeedClimbingABM.R")
#load packages
library(caret)
library(gbm)
library(ranger)
library(glmnet)
library(cito)
library(xgboost)
#create custom model specification for cito (torch) in caret
cito_fit <- function(x, y, wts, param, lev, last, weight, classProbs, ...){
dat <- if(is.data.frame(x)) x else as.data.frame(x, stringsAsFactors = TRUE)
dat$.outcome <- y
if(param$regular){
model <- cito::dnn(.outcome ~ .,
data = dat,
lr = param$lr,
dropout = param$dropout,
hidden = c(500, 500),
loss = "mse", optimizer = "adam", activation = "relu",
alpha = 0.2, lambda = 0.001,
device = "cpu",
plot = FALSE,
...)
}
if(!param$regular){
model <- cito::dnn(.outcome ~ .,
data = dat,
lr = param$lr,
dropout = param$dropout,
hidden = c(500, 500),
loss = "mse", optimizer = "adam", activation = "relu",
device = "cpu",
plot = FALSE,
...)
}
class(model) <- "citodnn"
return(model)
}
cito_predict <- function(modelFit, newdata, preProc = NULL, submodels = NULL){
out <- as.numeric(cito:::predict.citodnn(modelFit, newdata, type = "response", device = "cpu"))
}
cito_dnn <- list(
library = c("cito", "torch", "coro", "checkmate", "gridExtra", "parabar", "abind", "progress", "cli"),
type = "Regression",
parameters = data.frame(parameter = c("lr", "dropout", "regular"),
class = c("numeric", "numeric", "boolean"),
label = c("Learning Rate", "Dropout", "Regularization"))
)
cito_dnn$fit <- cito_fit
cito_dnn$predict <- cito_predict
cito_dnn$grid <- function(){}
cito_dnn$prob <- function(){}
#logit and inverse logit functions with bounds
logit <- function(p, bounds){
norm_p <- (p - bounds[1])/(bounds[2] - bounds[1])
return(log(norm_p/(1-norm_p)))
}
inv_logit <- function(l, bounds){
inv_l <- exp(l)/(1+exp(l))
return((inv_l*(bounds[2] - bounds[1])) + bounds[1])
}
#get all unique climbers
uniq_climbers <- unique(data$athlete)
#separate continuous sequences of years
seqs <- lapply(uniq_climbers, function(x){split(data$year[which(data$athlete == x)], cumsum(seq_along(data$year[which(data$athlete == x)]) %in% (which(diff(data$year[which(data$athlete == x)]) > 1) + 1)))})
#for each unique climber, iterate through their sequences, and and extract their ID, start year, end year, and time in start year (separate row per sequence)
pop_data <- data.table::data.table(do.call(rbind, lapply(1:length(uniq_climbers), function(i){
t(sapply(1:length(seqs[[i]]), function(j){
c(uniq_climbers[i], min(unlist(seqs[[i]][j])), max(unlist(seqs[[i]][j])), data$time[which(data$athlete == uniq_climbers[i] & data$year == min(unlist(seqs[[i]][j])))])
}))
})))
colnames(pop_data) <- c("ID", "start", "end", "time")
pop_data
uniq_climbers
data$athlete
uniq_climbers
data$athlete
data
table(data$gender)
?match
match(uniq_climbers, data$athlete)
data$gender[match(uniq_climbers, data$athlete)]
data$gender[match(pop_data$ID, data$athlete)]
pop_data$gender <- data$gender[match(pop_data$ID, data$athlete)]
pop_data
pop_data[, c(1, 5, 2, 3, 4)]
pop_data <- pop_data[, c(1, 5, 2, 3, 4)]
pop_data$gender
setwd("/Users/masonyoungblood/Documents/Work/Summer_2021/Speed Climbing/SpeedClimbingABM")
load("data.RData")
grid <- read.csv("grid.csv")/1000
source("SpeedClimbingABM.R")
#load packages
library(caret)
library(gbm)
library(ranger)
library(glmnet)
library(cito)
library(xgboost)
#create custom model specification for cito (torch) in caret
cito_fit <- function(x, y, wts, param, lev, last, weight, classProbs, ...){
dat <- if(is.data.frame(x)) x else as.data.frame(x, stringsAsFactors = TRUE)
dat$.outcome <- y
if(param$regular){
model <- cito::dnn(.outcome ~ .,
data = dat,
lr = param$lr,
dropout = param$dropout,
hidden = c(500, 500),
loss = "mse", optimizer = "adam", activation = "relu",
alpha = 0.2, lambda = 0.001,
device = "cpu",
plot = FALSE,
...)
}
if(!param$regular){
model <- cito::dnn(.outcome ~ .,
data = dat,
lr = param$lr,
dropout = param$dropout,
hidden = c(500, 500),
loss = "mse", optimizer = "adam", activation = "relu",
device = "cpu",
plot = FALSE,
...)
}
class(model) <- "citodnn"
return(model)
}
cito_predict <- function(modelFit, newdata, preProc = NULL, submodels = NULL){
out <- as.numeric(cito:::predict.citodnn(modelFit, newdata, type = "response", device = "cpu"))
}
cito_dnn <- list(
library = c("cito", "torch", "coro", "checkmate", "gridExtra", "parabar", "abind", "progress", "cli"),
type = "Regression",
parameters = data.frame(parameter = c("lr", "dropout", "regular"),
class = c("numeric", "numeric", "boolean"),
label = c("Learning Rate", "Dropout", "Regularization"))
)
cito_dnn$fit <- cito_fit
cito_dnn$predict <- cito_predict
cito_dnn$grid <- function(){}
cito_dnn$prob <- function(){}
#logit and inverse logit functions with bounds
logit <- function(p, bounds){
norm_p <- (p - bounds[1])/(bounds[2] - bounds[1])
return(log(norm_p/(1-norm_p)))
}
inv_logit <- function(l, bounds){
inv_l <- exp(l)/(1+exp(l))
return((inv_l*(bounds[2] - bounds[1])) + bounds[1])
}
#get all unique climbers
uniq_climbers <- unique(data$athlete)
#separate continuous sequences of years
seqs <- lapply(uniq_climbers, function(x){split(data$year[which(data$athlete == x)], cumsum(seq_along(data$year[which(data$athlete == x)]) %in% (which(diff(data$year[which(data$athlete == x)]) > 1) + 1)))})
#for each unique climber, iterate through their sequences, and and extract their ID, start year, end year, and time in start year (separate row per sequence)
pop_data <- data.table::data.table(do.call(rbind, lapply(1:length(uniq_climbers), function(i){
t(sapply(1:length(seqs[[i]]), function(j){
c(uniq_climbers[i], min(unlist(seqs[[i]][j])), max(unlist(seqs[[i]][j])), data$time[which(data$athlete == uniq_climbers[i] & data$year == min(unlist(seqs[[i]][j])))])
}))
})))
colnames(pop_data) <- c("ID", "start", "end", "time")
pop_data$gender <- data$gender[match(pop_data$ID, data$athlete)]
pop_data <- pop_data[, c(1, 5, 2, 3, 4)]
#get years
years <- sort(unique(data$year))
#get population sizes
n <- unlist(lapply(1:length(years), function(x){nrow(data[which(data$year == years[x]), ])}))
n
SpeedClimbingABM(n = n, years = years, pop_data = pop_data, grid = grid, n_holds = 20,
beta_true_prob = 1,
innov_prob = 0.2,
learn_prob = 0,
n_top = 0,
improve_rate_m = 2,
improve_rate_w = 2,
max_dist = 1.645,
improve_min_m = 0.3427374,
improve_min_w = 0.3527184,
sum_stats = FALSE, plot = TRUE)
SpeedClimbingABM(n = n, years = years, pop_data = pop_data, grid = grid, n_holds = 20,
beta_true_prob = 1,
innov_prob = 0.2,
learn_prob = 0,
n_top = 0,
improve_rate_m = 2,
improve_rate_w = 2,
max_dist = 1.645,
improve_min_m = 0.3427374,
improve_min_w = 0.3527184,
sum_stats = FALSE, plot = TRUE)
#number of simulations
n_sim <- 10
#set priors
priors <- data.frame(innov_prob = runif(n_sim, 0, 1),
learn_prob = runif(n_sim, 0, 1),
n_top = runif(n_sim, 0, 1),
improve_rate_m = runif(n_sim, 1, 3))
load("/Users/masonyoungblood/Documents/Work/Summer_2021/Speed Climbing/SpeedClimbingABM/local/priors_and_simulations.RData")
priors_and_simulations[[1]]
priors_and_simulations[[2]][[1]]
priors_and_simulations[[2]][[1]][-1]
unlist(priors_and_simulations[[2]][[1]][-1])
sum_stats <- do.call(rbind, lapply(1:length(priors_and_simulations[[2]]), function(x){unlist(priors_and_simulations[[2]][[x]][-1])}))
str(sum_stats)
priors <- priors_and_simulations[[1]]
combined <- cbind(priors, sum_stats)
combined <- scale(combined)
combined
combined[1, ]
combined[2, ]
combined[4, ]
write.table(combined[1:10000, ], sep = ",", row.names = FALSE, col.names = FALSE,
file = "/Users/masonyoungblood/Documents/Work/Fall 2023/BayesFlow Exploring/data.csv")
ncol(priors)
ncol(sum_stats)
write.table(combined[1:80000, ], sep = ",", row.names = FALSE, col.names = FALSE,
file = "/Users/masonyoungblood/Documents/Work/Fall 2023/BayesFlow Exploring/train_set.csv")
write.table(combined[80001:100000, ], sep = ",", row.names = FALSE, col.names = FALSE,
file = "/Users/masonyoungblood/Documents/Work/Fall 2023/BayesFlow Exploring/test_set.csv")
write.table(combined[80001:80100, ], sep = ",", row.names = FALSE, col.names = FALSE,
file = "/Users/masonyoungblood/Documents/Work/Fall 2023/BayesFlow Exploring/test_set.csv")
#define sizes of train and test set
train_size <- 99000
test_size <- 1000
train_size + test_size
(train_size + 1):(train_size + test_size)
load("~/Documents/Work/Summer_2021/Speed Climbing/SpeedClimbingABM/local/speed_climbing/tuning.RData")
tuning
tuning[[1]]
tuning[[1]]$dnn
tuning[[1]]$dnn$Rsquared
max(tuning[[1]]$dnn$Rsquared)
max(tuning[[1]]$dnn$Rsquared, na.rm = TRUE)
max(tuning[[2]]$dnn$Rsquared, na.rm = TRUE)
max(tuning[[3]]$dnn$Rsquared, na.rm = TRUE)
max(tuning[[4]]$dnn$Rsquared, na.rm = TRUE)
max(tuning[[5]]$dnn$Rsquared, na.rm = TRUE)
max(tuning[[5]]$xgb$Rsquared, na.rm = TRUE)
max(tuning[[4]]$xgb$Rsquared, na.rm = TRUE)
max(tuning[[3]]$xgb$Rsquared, na.rm = TRUE)
max(tuning[[2]]$xgb$Rsquared, na.rm = TRUE)
max(tuning[[1]]$xgb$Rsquared, na.rm = TRUE)
load("/Users/masonyoungblood/Documents/Work/Summer_2021/Speed Climbing/SpeedClimbingABM/data.RData")
data
priors_and_simulations[[2]][[1]]
which(data$year == 2008)
data$time[which(data$year == 2008)]
sort(data$time[which(data$year == 2008)])
max(data$year)
lapply(2008:2019, function(x){sort(data$time[which(data$year == x)])})
unlist(lapply(2008:2019, function(x){sort(data$time[which(data$year == x)])}))
obs_data <- unlist(lapply(2008:2019, function(x){sort(data$time[which(data$year == x)])}))
obs_data
obs_data
data.frame(obs_data = obs_data)
#compute observed summary statistics
obs_data <- data.frame(obs_data = unlist(lapply(2008:2019, function(x){sort(data$time[which(data$year == x)])})))
write.table(obs_data, sep = ",", row.names = FALSE, col.names = FALSE,
file = "/Users/masonyoungblood/Documents/Work/Fall 2023/BayesFlow Exploring/obs_data.csv")
#load simulations and data
load("/Users/masonyoungblood/Documents/Work/Summer_2021/Speed Climbing/SpeedClimbingABM/local/priors_and_simulations.RData")
load("/Users/masonyoungblood/Documents/Work/Summer_2021/Speed Climbing/SpeedClimbingABM/data.RData")
#extract priors and summary statistics
priors <- priors_and_simulations[[1]]
sum_stats <- do.call(rbind, lapply(1:length(priors_and_simulations[[2]]), function(x){unlist(priors_and_simulations[[2]][[x]][-1])}))
#combine them into a single table
combined <- cbind(priors, sum_stats)
combined <- scale(combined)
#compute observed summary statistics
obs_data <- data.frame(obs_data = unlist(lapply(2008:2019, function(x){sort(data$time[which(data$year == x)])})))
#define sizes of train and test set
train_size <- 90000
test_size <- 10000
#save everything needed by bayesflow
write.table(combined[1:train_size, ], sep = ",", row.names = FALSE, col.names = FALSE,
file = "/Users/masonyoungblood/Documents/Work/Fall 2023/BayesFlow Exploring/train_set.csv")
write.table(combined[(train_size + 1):(train_size + test_size), ], sep = ",", row.names = FALSE, col.names = FALSE,
file = "/Users/masonyoungblood/Documents/Work/Fall 2023/BayesFlow Exploring/test_set.csv")
write.table(obs_data, sep = ",", row.names = FALSE, col.names = FALSE,
file = "/Users/masonyoungblood/Documents/Work/Fall 2023/BayesFlow Exploring/obs_data.csv")
combined
str(combined)
attr(combined)
attr(combined)$"scaled:center"
combined$"scaled:center"
attributes(combined)$"scaled:center"
#set number of parameters
n_params <- ncol(priors)
n_params
attributes(combined)$"scaled:center"[, -c(1:n_params)]
attributes(combined)$"scaled:center"[-c(1:n_params)]
#compute observed summary statistics
obs_data <- unlist(lapply(2008:2019, function(x){sort(data$time[which(data$year == x)])}))
obs_data
attributes(combined)$"scaled:sd"[-c(1:n_params)]
attributes(combined)
(obs_data + attributes(combined)$"scaled:center"[-c(1:n_params)])*attributes(combined)$"scaled:scale"[-c(1:n_params)]
as.numeric((obs_data + attributes(combined)$"scaled:center"[-c(1:n_params)])*attributes(combined)$"scaled:scale"[-c(1:n_params)])
#compute observed summary statistics
obs_data <- unlist(lapply(2008:2019, function(x){sort(data$time[which(data$year == x)])}))
obs_data
mean(attributes(combined)$"scaled:center"[-c(1:n_params)])
obs_data
as.numeric((obs_data - attributes(combined)$"scaled:center"[-c(1:n_params)])/attributes(combined)$"scaled:scale"[-c(1:n_params)])
#compute observed summary statistics
obs_data <- unlist(lapply(2008:2019, function(x){sort(data$time[which(data$year == x)])}))
obs_data <- as.numeric((obs_data - attributes(combined)$"scaled:center"[-c(1:n_params)])/attributes(combined)$"scaled:scale"[-c(1:n_params)])
obs_data <- data.frame(obs_data = obs_data)
write.table(obs_data, sep = ",", row.names = FALSE, col.names = FALSE,
file = "/Users/masonyoungblood/Documents/Work/Fall 2023/BayesFlow Exploring/obs_data.csv")
obs_data
load("/Users/masonyoungblood/Documents/Work/Summer_2021/Speed Climbing/SpeedClimbingABM/data.RData")
which(data$gender == "W")
which(data$gender == "W" & data$year == 2007)
data$time[which(data$gender == "W" & data$year == 2007)]
data$time[which(data$gender == "W" & data$year == max(data$year))]
min(data$time[which(data$gender == "W" & data$year == max(data$year))])
min(data$time[which(data$gender == "W" & data$year == min(data$year))])
7.1/23.01
median(data$time[which(data$gender == "W" & data$year == max(data$year))])/median(data$time[which(data$gender == "W" & data$year == max(data$year))])
median(data$time[which(data$gender == "W" & data$year == max(data$year))])/median(data$time[which(data$gender == "W" & data$year == min(data$year))])
max(data$time[which(data$gender == "W" & data$year == max(data$year))])/max(data$time[which(data$gender == "W" & data$year == min(data$year))])
max(data$time[which(data$gender == "W" & data$year == max(data$year))])/min(data$time[which(data$gender == "W" & data$year == min(data$year))])
max(data$time[which(data$gender == "W" & data$year == max(data$year))])/max(data$time[which(data$gender == "W" & data$year == min(data$year))])
min(data$time[which(data$gender == "W" & data$year == max(data$year))])/max(data$time[which(data$gender == "W" & data$year == min(data$year))])
max(data$time[which(data$gender == "W" & data$year == max(data$year))])/max(data$time[which(data$gender == "W" & data$year == min(data$year))])
max(data$time[which(data$gender == "W" & data$year == max(data$year))])/min(data$time[which(data$gender == "W" & data$year == min(data$year))])
mean(data$time[which(data$gender == "W" & data$year == max(data$year))])/mean(data$time[which(data$gender == "W" & data$year == min(data$year))])
median(data$time[which(data$gender == "W" & data$year == max(data$year))])/median(data$time[which(data$gender == "W" & data$year == min(data$year))])
max(data$year)
median(data$time[which(data$gender == "W" & data$year == 2019)])/median(data$time[which(data$gender == "W" & data$year == 2007)])
median(data$time[which(data$gender == "W" & data$year == 2019)])
data$time[which(data$gender == "W" & data$year == 2019)]
data$time[which(data$gender == "W" & data$year == 2019)]/20
median(data$time[which(data$gender == "W" & data$year == 2019)]/20)
median(data$time[which(data$gender == "W" & data$year == 2019)]/20)/median(data$time[which(data$gender == "W" & data$year == 2007)]/20)
(median(data$time[which(data$gender == "W" & data$year == 2019)])/20)/median(data$time[which(data$gender == "W" & data$year == 2007)]/20)
(median(data$time[which(data$gender == "W" & data$year == 2019)])/20)/(median(data$time[which(data$gender == "W" & data$year == 2007)])/20)
data$time[which(data$gender == "W" & data$year == 2019)]
median(data$time[which(data$gender == "W" & data$year == 2019)])
median(data$time[which(data$gender == "W" & data$year == 2019)])/20
median(data$time[which(data$gender == "W" & data$year == 2007)])
median(data$time[which(data$gender == "W" & data$year == 2019)])
median(data$time[which(data$gender == "W" & data$year == 2019)])/median(data$time[which(data$gender == "W" & data$year == 2007)])
median(data$time[which(data$gender == "M" & data$year == 2019)])/median(data$time[which(data$gender == "M" & data$year == 2007)])
mean(data$time[which(data$gender == "M" & data$year == 2019)])/mean(data$time[which(data$gender == "M" & data$year == 2007)])
(median(data$time[which(data$gender == "M" & data$year == 2019)])/15)/median(data$time[which(data$gender == "M" & data$year == 2007)])
(median(data$time[which(data$gender == "M" & data$year == 2019)])/15)/(median(data$time[which(data$gender == "M" & data$year == 2007)])/20)
(median(data$time[which(data$gender == "M" & data$year == 2019)])/15)/(median(data$time[which(data$gender == "M" & data$year == 2007)])/20)
(median(data$time[which(data$gender == "W" & data$year == 2019)])/15)/(median(data$time[which(data$gender == "W" & data$year == 2007)])/20)
#logit functions for interactions
logit <- function(p){return(log(p/(1-p)))}
inv_logit <- function(l){return(exp(l)/(1+exp(l)))}
logit(0.6)
logit(0.1)
logit(0.9)
