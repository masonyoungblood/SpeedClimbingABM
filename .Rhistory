SpeedClimbingABM_slurm <- function(innov_prob, learn_prob, n_top, adj_poss, improve_rate_m, improve_rate_sd, improve_min){
c(t(SpeedClimbingABM(n = n, years = years, pop_data = pop_data, n_holds = 20,
beta_true_prob = 1, innov_prob = innov_prob, learn_prob = learn_prob, n_top = n_top, adj_poss = adj_poss,
improve_rate_m = improve_rate_m, improve_rate_sd = improve_rate_sd, improve_min = improve_min,
sum_stats = FALSE, plot = FALSE)))
}
sim_stats <- SpeedClimbingABM_slurm(0.5, 0.5, 5, 2, 1, 1, 1)
lengths(sim_stats)
lengths(obs_stats)
pop_data_n <- sapply(1:length(years), function(x){length(which(sapply(1:nrow(pop_data), function(y){years[x] %in% pop_data[y, ]$start:pop_data[y, ]$end})))})
data_n <- unlist(lapply(1:length(years), function(x){nrow(data[which(data$year == years[x]), ])}))
pop_data_n
data_n
source("SpeedClimbingABM.R")
#wrap SpeedClimbingABM in a simpler function for slurm
SpeedClimbingABM_slurm <- function(innov_prob, learn_prob, n_top, adj_poss, improve_rate_m, improve_rate_sd, improve_min){
c(t(SpeedClimbingABM(n = n, years = years, pop_data = pop_data, n_holds = 20,
beta_true_prob = 1, innov_prob = innov_prob, learn_prob = learn_prob, n_top = n_top, adj_poss = adj_poss,
improve_rate_m = improve_rate_m, improve_rate_sd = improve_rate_sd, improve_min = improve_min,
sum_stats = FALSE, plot = FALSE)))
}
sim_stats <- SpeedClimbingABM_slurm(0.5, 0.5, 5, 2, 1, 1, 1)
#bounded exponential function for athletic improvement
bounded_exp <- function(x, rate, min){
return((1-min)*(rate/rate^x)+min)
}
#parameter definition for manual debugging
n_holds <- 20
beta_true_prob <- 1
innov_prob <- 0.1
innov_x_times <- 0
innov_x_pop <- 0
learn_prob <- 0.1
learn_x_times <- 0
learn_x_pop <- 0
n_top <- 10
adj_poss <- 2
improve_rate_m <- 2
improve_rate_sd <- 0.5
improve_min <- 0.8
sd_multiplier <- 0.5
sum_stats <- TRUE
plot <- TRUE
bw <- 1
ylim <- 0.3
quant_by <- 0.2
#round integer params
n_top <- round(n_top)
adj_poss <- round(adj_poss)
#colors for plotting after each timepoint
colors <- rainbow((length(n)-1)*1.25) #times 1.2 so it doesn't loop back around
#get booleans for whether learning and innovation needs to be individually calculated, and normalize population size
learn_bool <- learn_x_times > 0 | learn_x_pop > 0
innov_bool <- innov_x_times > 0 | innov_x_pop > 0
n_norm <- BBmisc::normalize(n, "range", c(-0.5, 0.5))
knitr::include_graphics("https://helios-i.mashable.com/imagery/articles/03XKxYMwkNiZJGiHUu2FWnw/hero-image.fill.size_1248x702.v1628089817.png")
#bounded exponential function
bounded_exp <- function(x, rate, min){
return((1-min)*(rate/rate^x)+min)
}
# #generate values
# x <- 1:12
# rates <- truncnorm::rtruncnorm(100, a = 1, mean = 2, sd = 0.2)
# y <- sapply(1:length(rates), function(h){bounded_exp(x, rates[h], 0.4)})
#generate values
x <- 1:12
rates <- truncnorm::rtruncnorm(100, a = 1, mean = 2.5, sd = 0.3)
y <- sapply(1:length(rates), function(h){bounded_exp(x, rates[h], 0.07)})
#plot
par(mar = c(4, 4, 1, 1))
matplot(x, y, type = "l", xlab = "Timestep", ylab = "Athletic Improvement", ylim = c(0, 1), col = scales::alpha("black", 0.2), lty = 1)
knitr::include_graphics("https://www.kindpng.com/picc/m/592-5929143_speed-climbing-wall-sketch-speed-climbing-route-map.png")
#set number of holds
n_holds <- 20
#set initial mean speed
init_time <- 18
#set probability of initial beta holds at 1 (all holds on the route)
beta_true_prob <- 1
#set parameter controlling the SD of sequence ratios
sd_multiplier <- 0.5
#initialize starting beta
beta <- sample(c(TRUE, FALSE), n_holds, prob = c(beta_true_prob, 1-beta_true_prob), replace = TRUE)
#initialize sequence ratios
seq_ratios <- truncnorm::rtruncnorm(n_holds, a = 0, mean = 1, sd = sd_multiplier)
#print the beta and climbing time vectors
beta
(init_time/n_holds)*seq_ratios
#get cumulative climbing times
cum_num <- cumsum(c(0, (init_time/n_holds)*seq_ratios))
#restructure and plot
to_plot <- data.frame(x = unlist(sapply(1:(length(cum_num)-1), function(x){seq(cum_num[x], cum_num[x+1], by = 0.01)})),
y = unlist(sapply(1:(length(cum_num)-1), function(x){rep(x, length(seq(cum_num[x], cum_num[x+1], by = 0.01)))})))
par(mar = c(4, 4, 1, 1))
plot(to_plot$x, to_plot$y, type = "l", xlab = "Time (s)", ylab = "Hold #")
load("data.RData")
data.table::data.table(data)
par(mar = c(4, 4, 1, 1))
hist(as.numeric(sort(table(data$athlete), decreasing = TRUE)), main = NULL, xlab = "# of Years")
#get all unique climbers
uniq_climbers <- unique(data$athlete)
#separate continuous sequences of years
seqs <- lapply(uniq_climbers, function(x){split(data$year[which(data$athlete == x)], cumsum(seq_along(data$year[which(data$athlete == x)]) %in% (which(diff(data$year[which(data$athlete == x)]) > 1) + 1)))})
#for each unique climber, iterate through their sequences, and and extract their ID, start year, end year, and time in start year (separate row per sequence)
pop_data <- data.table::data.table(do.call(rbind, lapply(1:length(uniq_climbers), function(i){
t(sapply(1:length(seqs[[i]]), function(j){
c(uniq_climbers[i], min(unlist(seqs[[i]][j])), max(unlist(seqs[[i]][j])), data$time[which(data$athlete == uniq_climbers[i] & data$year == min(unlist(seqs[[i]][j])))])
}))
})))
colnames(pop_data) <- c("ID", "start", "end", "time")
pop_data
#remove temp objects
rm(list = c("seqs", "uniq_climbers"))
pop_data_n <- sapply(1:length(years), function(x){length(which(sapply(1:nrow(pop_data), function(y){years[x] %in% pop_data[y, ]$start:pop_data[y, ]$end})))})
load("data.RData")
pop_data <- pop_data[which(data$gender[match(pop_data$ID, data$athlete)] == "M"), ]
data <- data[which(data$gender == "M"), ]
#get years
years <- sort(unique(data$year))
#population sizes
n <- unlist(lapply(1:length(years), function(x){nrow(data[which(data$year == years[x]), ])}))
n_holds <- 20
beta_true_prob <- 1
innov_prob <- 0.1
innov_x_times <- 0
innov_x_pop <- 0
learn_prob <- 0.1
learn_x_times <- 0
learn_x_pop <- 0
n_top <- 10
adj_poss <- 2
improve_rate_m <- 2
improve_rate_sd <- 0.5
improve_min <- 0.8
sd_multiplier <- 0.5
sum_stats <- TRUE
plot <- TRUE
bw <- 1
ylim <- 0.3
quant_by <- 0.2
#round integer params
n_top <- round(n_top)
adj_poss <- round(adj_poss)
#colors for plotting after each timepoint
colors <- rainbow((length(n)-1)*1.25) #times 1.2 so it doesn't loop back around
#get booleans for whether learning and innovation needs to be individually calculated, and normalize population size
learn_bool <- learn_x_times > 0 | learn_x_pop > 0
innov_bool <- innov_x_times > 0 | innov_x_pop > 0
n_norm <- BBmisc::normalize(n, "range", c(-0.5, 0.5))
#initialize starting beta for all agents
beta <- sample(c(TRUE, FALSE), n_holds, prob = c(beta_true_prob, 1-beta_true_prob), replace = TRUE)
#initialize data table of agents
climbers <- data.table::data.table(ID = pop_data$ID[which(pop_data$start == years[1])],
ref_times = pop_data$time[which(pop_data$start == years[1])]/sum(beta),
beta = lapply(1:n[1], function(x){beta}),
seq_ratios = lapply(1:n[1], function(x){truncnorm::rtruncnorm(n_holds, a = 0, mean = 1, sd = sd_multiplier)}),
ath_imp = lapply(1:n[1], function(x){bounded_exp(1:length(n), truncnorm::rtruncnorm(1, a = 1, mean = improve_rate_m, sd = improve_rate_sd), improve_min)}),
current_record = pop_data$time[which(pop_data$start == years[1])])
#create output list
output <- list()
#store the output from initialization
if(sum_stats){output[[1]] <- quantile(climbers$current_record, probs = seq(0, 1, quant_by))}
if(!sum_stats){output[[1]] <- sort(climbers$current_record)}
i <- 2
n
#get top n climbers for each climber to compare themselves with
top_climbers <- order(climbers$current_record)[1:n_top]
#if needed, calculate the unique learn_prob and innov_prob for each old and new climber in this timestep
t_norm <- BBmisc::normalize(1/climbers$current_record, "range", c(-0.5, 0.5)) #take inverse of current record so smaller is better
if(learn_bool){learn_prob_ind <- sapply(1:nrow(climbers), function(x){learn_prob + learn_prob*t_norm[x]*learn_x_times + learn_prob*n_norm[i]*learn_x_pop})}
if(innov_bool){innov_prob_ind <- sapply(1:nrow(climbers), function(x){innov_prob + innov_prob*t_norm[x]*innov_x_times + innov_prob*n_norm[i]*innov_x_pop})}
#get who will learn
if(learn_bool){to_learn <- sapply(1:nrow(climbers), function(x){sample(c(TRUE, FALSE), 1, prob = c(learn_prob_ind[x], 1-learn_prob_ind[x]))})}
if(!learn_bool){to_learn <- sample(c(TRUE, FALSE), nrow(climbers), prob = c(learn_prob, 1-learn_prob), replace = TRUE)}
#for each climber who is sampled
for(k in c(1:nrow(climbers))[which(to_learn)]){
#find out which top climbers have different beta than climber k
diff_top_climbers <- top_climbers[which(sapply(top_climbers, function(x){!identical(climbers$beta[[k]], climbers$beta[[top_climbers[x]]])}))]
#if there are top climbers with different beta
if(length(diff_top_climbers) > 0){
#get possible new times for climber k assuming the beta and seq_ratios of the top climbers with different beta
poss_new_times <- sapply(diff_top_climbers, function(x){sum((climbers$ref_times[x]*climbers$seq_ratios[[x]]*climbers$ath_imp[[x]][i])[climbers$beta[[x]]])})
#if the lowest possible new time is better than the current record, then replace the beta and seq_ratio of climber k with beta from best beta from top climbers
if(min(poss_new_times) < climbers$current_record[k]){
climbers$beta[[k]] <- climbers$beta[[diff_top_climbers[which.min(poss_new_times)]]]
climbers$seq_ratios[[k]] <- climbers$seq_ratios[[diff_top_climbers[which.min(poss_new_times)]]]
}
rm(list = c("poss_new_times"))
}
rm(list = c("diff_top_climbers"))
}
#get who will innovate
if(innov_bool){to_flip <- which(sapply(1:nrow(climbers), function(x){sample(c(TRUE, FALSE), 1, prob = c(innov_prob_ind[x], 1-innov_prob_ind[x]))}))}
if(!innov_bool){to_flip <- which(sample(c(TRUE, FALSE), nrow(climbers), prob = c(innov_prob, 1-innov_prob), replace = TRUE))}
#if individuals are going to change their beta
if(length(to_flip) > 0){
#go through individuals
for(j in to_flip){
#store original beta
beta_a <- climbers$beta[[j]]
seq_ratios_a <- climbers$seq_ratios[[j]]
#if there are any FALSE positions
if(length(which(beta_a == FALSE) > 0)){
#iterate through beta and figure out which positions are okay to flip (do not create strings of FALSE that exceed adj_poss)
ok_holds <- which(sapply(1:length(beta_a), function(x){
#make copy of beta_a to test whether position is okay
temp <- beta_a
temp[x] <- !temp[x]
#if the flip doesn't change everything to TRUE (rare case that throws warning)
if(length(which(temp == FALSE) > 0)){
#if the maximum string of FALSEs, assuming this position flips, is less than or equal to adj_poss, then it's okay to flip
if(max(rle(temp)$lengths[which(rle(temp)$values == FALSE)]) <= adj_poss){
return(TRUE)
} else{
return(FALSE)
}
} else{
return(TRUE)
}
#remove temp object
rm(temp)
}))
} else{
ok_holds <- c(1:n_holds)
}
#make a copy
beta_b <- beta_a
seq_ratios_b <- seq_ratios_a
#choose position to flip
beta_to_flip <- sample(ok_holds, 1)
#flip a position into copied beta
beta_b[beta_to_flip] <- !beta_b[beta_to_flip]
#resample adjacent seq_ratios
seq_ratios_b[ok_holds[which(ok_holds == beta_to_flip)-1]] <- truncnorm::rtruncnorm(1, a = 0, mean = 1, sd = sd_multiplier)
seq_ratios_b[ok_holds[which(ok_holds == beta_to_flip)+1]] <- truncnorm::rtruncnorm(1, a = 0, mean = 1, sd = sd_multiplier)
#decide which is better
sum_a <- sum(seq_ratios_a[beta_a])
sum_b <- sum(seq_ratios_b[beta_b])
#if new one is better, then overwrite current
if(sum_b < sum_a){
climbers$beta[[j]] <- beta_b
climbers$seq_ratios[[j]] <- seq_ratios_b
}
#remove temporary objects
rm(list = c("beta_a", "seq_ratios_a", "ok_holds", "beta_b", "seq_ratios_b", "beta_to_flip", "sum_a", "sum_b"))
}
}
#get indices of climbers whose beta and sequence ratios will be randomly sampled for new climbers
add_inds <- sample(1:nrow(climbers), length(which(pop_data$start == years[i])), replace = TRUE)
#generate data table of new climbers
new_climbers <- data.table::data.table(ID = pop_data$ID[which(pop_data$start == years[i])],
ref_times = pop_data$time[which(pop_data$start == years[i])]/sapply(1:length(climbers$beta[add_inds]), function(x){sum(climbers$beta[add_inds][[x]])}),
beta = climbers$beta[add_inds],
seq_ratios = climbers$seq_ratios[add_inds],
ath_imp = lapply(1:length(which(pop_data$start == years[i])), function(x){bounded_exp(1:length(n), truncnorm::rtruncnorm(1, a = 1, mean = improve_rate_m, sd = improve_rate_sd), improve_min)}),
current_record = pop_data$time[which(pop_data$start == years[i])])
new_climbers
climbers
n
#scale athletic improvement of new climbers to keep them on same trajectory as old climbers
new_climbers$ath_imp <- lapply(1:nrow(new_climbers), function(x){new_climbers$ath_imp[[x]]/new_climbers$ath_imp[[x]][i]})
which(climbers$ID %in% pop_data$ID[which(pop_data$end == years[i-1])])
#simulate leaving the sport
climbers <- climbers[-which(climbers$ID %in% pop_data$ID[which(pop_data$end == years[i-1])]), ]
#store current record of old climbers
climbers$current_record <- sapply(1:nrow(climbers), function(x){sum((climbers$ref_times[x]*climbers$seq_ratios[[x]]*climbers$ath_imp[[x]][i])[climbers$beta[[x]]])})
climbers
new_climbers
n
#combine data tables of old and new climbers
climbers <- data.table::rbindlist(list(climbers, new_climbers))
climbers
#set working directory, load data, source code
#setwd("~/Documents/Work/Summer_2021/Speed Climbing/SpeedClimbingABM") #local test
setwd(system("pwd", intern = T))
load("data.RData")
source("SpeedClimbingABM.R")
#euclidean distance function
euclidean <- function(a, b){
sqrt(sum((a-b)^2))
}
#random seed
set.seed(12345)
#subset data to only include men
data <- data[which(data$gender == "M"), ]
#get all unique climbers
uniq_climbers <- unique(data$athlete)
#separate continuous sequences of years
seqs <- lapply(uniq_climbers, function(x){split(data$year[which(data$athlete == x)], cumsum(seq_along(data$year[which(data$athlete == x)]) %in% (which(diff(data$year[which(data$athlete == x)]) > 1) + 1)))})
#for each unique climber, iterate through their sequences, and and extract their ID, start year, end year, and time in start year (separate row per sequence)
pop_data <- data.table::data.table(do.call(rbind, lapply(1:length(uniq_climbers), function(i){
t(sapply(1:length(seqs[[i]]), function(j){
c(uniq_climbers[i], min(unlist(seqs[[i]][j])), max(unlist(seqs[[i]][j])), data$time[which(data$athlete == uniq_climbers[i] & data$year == min(unlist(seqs[[i]][j])))])
}))
})))
colnames(pop_data) <- c("ID", "start", "end", "time")
pop_data
#get years
years <- sort(unique(data$year))
#get population sizes
n <- unlist(lapply(1:length(years), function(x){nrow(data[which(data$year == years[x]), ])}))
pop_data_n <- sapply(1:length(years), function(x){length(which(sapply(1:nrow(pop_data), function(y){years[x] %in% pop_data[y, ]$start:pop_data[y, ]$end})))})
data_n <- unlist(lapply(1:length(years), function(x){nrow(data[which(data$year == years[x]), ])}))
#get observed summary statistics
obs_stats <- lapply(years, function(x){sort(data$time[which(data$year == x)])})
#wrap SpeedClimbingABM in a simpler function for slurm
SpeedClimbingABM_slurm <- function(innov_prob, learn_prob, n_top, adj_poss, improve_rate_m, improve_rate_sd, improve_min){
c(t(SpeedClimbingABM(n = n, years = years, pop_data = pop_data, n_holds = 20,
beta_true_prob = 1, innov_prob = innov_prob, learn_prob = learn_prob, n_top = n_top, adj_poss = adj_poss,
improve_rate_m = improve_rate_m, improve_rate_sd = improve_rate_sd, improve_min = improve_min,
sum_stats = FALSE, plot = FALSE)))
}
sim_stats <- SpeedClimbingABM_slurm(0.5, 0.5, 5, 2, 1, 1, 1)
lengths(sim_stats)
lengths(obs_stats)
euclidean(obs_stats[[2]], sim_stats[[2]])
euclidean(obs_stats[[3]], sim_stats[[3]])
euclidean(obs_stats[[4]], sim_stats[[4]])
euclidean(obs_stats[[5]], sim_stats[[5]])
euclidean(obs_stats[[6]], sim_stats[[6]])
length(obs_stats)
1/c(1:134)
1/c(1:13)
1/c(13:1)
1/c(13:1)^2
1/c(13:1)^0.5
1/c(13:1)^0.2
1/c(13:1)^0.5
1/c(length(a):1)^0.5
a <- obs_stats[-1]
a
1/c(length(a):1)^0.5
1/c(length(a):1)^0.5
1/c(length(a):1)^0.5
weights <- 1/c(length(a):1)^c
c <- 0.5
weights <- 1/c(length(a):1)^c
weights
b <- sim_stats[-1]
a[[1]]
sqrt(sum((a[[x]]-b[[x]])^2))
x <- 1
sqrt(sum((a[[x]]-b[[x]])^2))
sqrt(sum((a[[x]]-b[[x]])^2))
sqrt(sum((a[[x]]-b[[x]])^2))*weights[x]
sqrt(sum((a[[x]]-b[[x]])^2))*weights[x]
sqrt(sum((a[[x]]-b[[x]])^2))*weights[x]
sqrt(sum((a[[x]]-b[[x]])^2))*weights[x]
sqrt(sum((a[[x]]-b[[x]])^2))*weights[x]
sqrt(sum((a[[x]]-b[[x]])^2))*weights[x]
sqrt(1)
sqrt(2)
sqrt(3)
sqrt(1/3)
sqrt(1/1)
sqrt(1/2)
sqrt(1/3)
sqrt(1/10)
divs <- c(length(a):1)
divs
divs
a[[x]]
a[[x]] - b[[x]]
a[[x]] - b[[x]]^2
sum(a[[x]] - b[[x]]^2)
sqrt(sum(a[[x]] - b[[x]]^2))
a[[1]]
b[[1]]
sqrt(sum((a[[x]] - b[[x]])^2))
sqrt(sum((a[[x]] - b[[x]])^2))
sqrt(sum((a[[x]] - b[[x]])^2))
sum((a[[x]] - b[[x]])^2)
sum((a[[x]] - b[[x]])^2)*divs[[x]]
sqrt(sum((a[[x]] - b[[x]])^2)*divs[[x]])
sqrt(sum((a[[x]] - b[[x]])^2)/divs[[x]])
sqrt(sum((a[[x]] - b[[x]])^2)/divs[[x]])
#weighted euclidean distance function, where a and b are lists of vectors
weighted_euclidean <- function(a, b){
divs <- c(length(a):1)
return(sapply(1:length(a), function(x){sqrt(sum((a[[x]] - b[[x]])^2)/divs[[x]])}))
}
weighted_euclidean(obs_stats, sim_stats)
weighted_euclidean(obs_stats, sim_stats)
weighted_euclidean(obs_stats, sim_stats)
#weighted euclidean distance function, where a and b are lists of vectors
weighted_euclidean <- function(a, b, weighted = FALSE){
divs <- c(length(a):1)
if(weighted){
return(sapply(1:length(a), function(x){sqrt(sum((a[[x]] - b[[x]])^2)/divs[[x]])}))
} else{
return(sapply(1:length(a), function(x){sqrt(sum((a[[x]] - b[[x]])^2))}))
}
}
weighted_euclidean(obs_stats, sim_stats)
weighted_euclidean(obs_stats, sim_stats, weighted = TRUE)
#weighted euclidean distance function, where a and b are lists of vectors,
weighted_euclidean <- function(a, b, weighted = FALSE){
divs <- c(length(a):1)
if(weighted){
return(sapply(1:length(a), function(x){sqrt(sum((a[[x]] - b[[x]])^2)/divs[[x]])}))
} else{
return(sapply(1:length(a), function(x){sqrt(sum((a[[x]] - b[[x]])^2))}))
}
}
SpeedClimbingABM_slurm(0.5, 0.5, 5, 2, 1, 1, 1)
#wrap SpeedClimbingABM in a simpler function for slurm
SpeedClimbingABM_slurm <- function(innov_prob, learn_prob, n_top, adj_poss, improve_rate_m, improve_rate_sd, improve_min){
SpeedClimbingABM(n = n, years = years, pop_data = pop_data, n_holds = 20,
beta_true_prob = 1, innov_prob = innov_prob, learn_prob = learn_prob, n_top = n_top, adj_poss = adj_poss,
improve_rate_m = improve_rate_m, improve_rate_sd = improve_rate_sd, improve_min = improve_min,
sum_stats = FALSE, plot = FALSE)
}
sim_stats <- SpeedClimbingABM_slurm(0.5, 0.5, 5, 2, 1, 1, 1)
sim_stats
sim_stats
#wrap SpeedClimbingABM in a simpler function for slurm
SpeedClimbingABM_slurm <- function(innov_prob, learn_prob, n_top, adj_poss, improve_rate_m, improve_rate_sd, improve_min){
SpeedClimbingABM(n = n, years = years, pop_data = pop_data, n_holds = 20,
beta_true_prob = 1, innov_prob = innov_prob, learn_prob = learn_prob, n_top = n_top, adj_poss = adj_poss,
improve_rate_m = improve_rate_m, improve_rate_sd = improve_rate_sd, improve_min = improve_min,
sum_stats = FALSE, plot = FALSE)
}
sim_stats <- SpeedClimbingABM_slurm(0.5, 0.5, 5, 2, 1, 1, 1)
sim_stats
#weighted euclidean distance function, where a and b are lists of vectors,
weighted_euclidean <- function(a, b, weighted = FALSE){
divs <- c(length(a):1)
if(weighted){
return(sum(sapply(1:length(a), function(x){sqrt(sum((a[[x]] - b[[x]])^2)/divs[[x]])})))
} else{
return(sum(sapply(1:length(a), function(x){sqrt(sum((a[[x]] - b[[x]])^2))})))
}
}
#wrap SpeedClimbingABM in a simpler function for slurm
SpeedClimbingABM_slurm <- function(innov_prob, learn_prob, n_top, adj_poss, improve_rate_m, improve_rate_sd, improve_min){
SpeedClimbingABM(n = n, years = years, pop_data = pop_data, n_holds = 20,
beta_true_prob = 1, innov_prob = innov_prob, learn_prob = learn_prob, n_top = n_top, adj_poss = adj_poss,
improve_rate_m = improve_rate_m, improve_rate_sd = improve_rate_sd, improve_min = improve_min,
sum_stats = FALSE, plot = FALSE)
}
#wrap SpeedClimbingABM in a simpler function for slurm
SpeedClimbingABM_slurm <- function(innov_prob, learn_prob, n_top, adj_poss, improve_rate_m, improve_rate_sd, improve_min){
temp <- SpeedClimbingABM(n = n, years = years, pop_data = pop_data, n_holds = 20,
beta_true_prob = 1, innov_prob = innov_prob, learn_prob = learn_prob, n_top = n_top, adj_poss = adj_poss,
improve_rate_m = improve_rate_m, improve_rate_sd = improve_rate_sd, improve_min = improve_min,
sum_stats = FALSE, plot = FALSE)
weighted_euclidean(obs_stats[-1], temp[-1])
}
SpeedClimbingABM_slurm(0.5, 0.5, 5, 2, 1, 1, 1)
SpeedClimbingABM_slurm(0.5, 0.5, 5, 2, 1, 1, 1)
SpeedClimbingABM_slurm(0.5, 0.5, 5, 2, 1, 1, 1)
SpeedClimbingABM_slurm(0.5, 0.5, 5, 2, 1, 1, 1)
SpeedClimbingABM_slurm(0.5, 0.5, 5, 2, 1, 1, 1)
SpeedClimbingABM_slurm(0.5, 0.5, 5, 2, 1, 1, 1)
SpeedClimbingABM_slurm(0.5, 0.5, 5, 2, 1, 1, 1)
SpeedClimbingABM_slurm(0, 0, 5, 2, 1, 1, 1)
SpeedClimbingABM_slurm(0, 0, 5, 2, 1, 1, 1)
SpeedClimbingABM_slurm(0, 0, 5, 2, 1, 1, 1)
SpeedClimbingABM_slurm(0, 0, 5, 2, 1, 1, 1)
SpeedClimbingABM_slurm(0, 0, 5, 2, 1, 1, 1)
SpeedClimbingABM_slurm(0, 0, 5, 2, 1, 1, 1)
SpeedClimbingABM_slurm(0, 0, 5, 2, 1, 1, 1)
SpeedClimbingABM_slurm(0, 0, 5, 2, 1, 1, 1)
SpeedClimbingABM_slurm(0, 0, 5, 2, 1, 1, 1)
SpeedClimbingABM_slurm(0, 0, 5, 2, 1, 1, 1)
SpeedClimbingABM_slurm(0, 0, 5, 2, 1, 1, 1)
SpeedClimbingABM_slurm(0, 0, 5, 2, 1, 1, 1)
SpeedClimbingABM_slurm(0, 0, 5, 2, 1, 1, 1)
SpeedClimbingABM_slurm(0, 0, 5, 2, 1, 1, 1)
SpeedClimbingABM_slurm(0, 0, 5, 2, 1, 1, 1)
SpeedClimbingABM_slurm(0, 0, 5, 2, 1, 1, 1)
SpeedClimbingABM_slurm(0, 0, 5, 2, 1, 1, 1)
SpeedClimbingABM_slurm(0, 0, 5, 2, 1, 1, 1)
SpeedClimbingABM_slurm(0, 0, 5, 2, 1, 1, 1)
SpeedClimbingABM_slurm(0, 0, 5, 2, 1, 1, 1)
SpeedClimbingABM_slurm(0, 0, 5, 2, 1, 1, 1)
SpeedClimbingABM_slurm(0, 0, 5, 2, 1, 1, 1)
SpeedClimbingABM_slurm(0, 0, 5, 2, 1, 1, 1)
SpeedClimbingABM_slurm(0, 0, 5, 2, 1, 1, 1)
SpeedClimbingABM_slurm(0, 0, 5, 2, 1, 1, 1)
SpeedClimbingABM_slurm(0, 0, 5, 2, 1, 1, 1)
SpeedClimbingABM_slurm(0, 0, 5, 2, 1, 1, 1)
SpeedClimbingABM_slurm(0.8, 0, 5, 2, 1, 1, 1)
SpeedClimbingABM_slurm(0.8, 0, 5, 2, 1, 1, 1)
SpeedClimbingABM_slurm(0, 0, 5, 2, 1, 1, 1)
SpeedClimbingABM_slurm(0, 0, 5, 2, 1, 1, 1)
SpeedClimbingABM_slurm(0, 0, 5, 2, 1, 1, 1)
SpeedClimbingABM_slurm(0, 0, 5, 2, 1, 1, 1)
SpeedClimbingABM_slurm(0.8, 0, 5, 2, 1, 1, 1)
SpeedClimbingABM_slurm(0.8, 0, 5, 2, 1, 1, 1)
SpeedClimbingABM_slurm(0.8, 0, 5, 2, 1, 1, 1)
SpeedClimbingABM_slurm(0.8, 0, 5, 2, 1, 1, 1)
SpeedClimbingABM_slurm(0.8, 0, 5, 2, 1, 1, 1)
SpeedClimbingABM_slurm(0.8, 0, 5, 2, 1, 1, 1)
SpeedClimbingABM_slurm(0.8, 0.8, 5, 2, 1, 1, 1)
SpeedClimbingABM_slurm(0.8, 0.8, 5, 2, 1, 1, 1)
SpeedClimbingABM_slurm(0.8, 0.8, 5, 2, 1, 1, 1)
SpeedClimbingABM_slurm(0.8, 0.8, 5, 2, 1, 1, 1)
SpeedClimbingABM_slurm(0.2, 0.2, 5, 2, 1, 1, 1)
SpeedClimbingABM_slurm(0.2, 0.2, 5, 2, 1, 1, 1)
SpeedClimbingABM_slurm(0.2, 0.2, 5, 2, 1, 1, 1)
SpeedClimbingABM_slurm(0.2, 0.2, 5, 2, 1, 1, 1)
SpeedClimbingABM_slurm(0.2, 0.2, 5, 2, 1, 1, 1)
SpeedClimbingABM_slurm(0.2, 0.2, 5, 2, 1, 1, 1)
SpeedClimbingABM_slurm(0.2, 0.2, 5, 2, 1, 1, 1)
SpeedClimbingABM_slurm(0.2, 0.2, 2, 2, 1, 1, 1)
SpeedClimbingABM_slurm(0.2, 0.2, 2, 2, 1, 1, 1)
SpeedClimbingABM_slurm(0.2, 0.2, 2, 2, 1, 1, 1)
SpeedClimbingABM_slurm(0.2, 0.2, 2, 2, 1, 1, 1)
SpeedClimbingABM_slurm(0.2, 0.2, 2, 2, 1, 1, 1)
SpeedClimbingABM_slurm(0.2, 0.2, 2, 2, 1, 1, 1)
SpeedClimbingABM_slurm(0.2, 0.2, 2, 2, 1, 1, 1)
obs_stats
