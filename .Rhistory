#get who will innovate
if(innov_bool){to_flip <- which(sapply(1:nrow(climbers), function(x){sample(c(TRUE, FALSE), 1, prob = c(innov_prob_ind[x], 1-innov_prob_ind[x]))}))}
if(!innov_bool){to_flip <- which(sample(c(TRUE, FALSE), nrow(climbers), prob = c(innov_prob, 1-innov_prob), replace = TRUE))}
to_flip
j <- 2
#store original beta
beta_a <- climbers$beta[[j]]
seq_ratios_a <- climbers$seq_ratios[[j]]
beta_a
seq_ratios_a
#parameter definition for manual debugging
n_holds <- 20
beta_true_prob <- 1
innov_prob <- 0.5
innov_x_times <- 0
innov_x_pop <- 0
learn_prob <- 0.5
learn_x_times <- 0
learn_x_pop <- 0
n_top <- 10
adj_poss <- 2
improve_rate_m <- 2
improve_rate_sd <- 0.5
improve_min <- 0.8
sd_multiplier <- 0.5
sum_stats <- TRUE
plot <- FALSE
bw <- 1
ylim <- 0.3
quant_by <- 0.2
#round integer params
n_top <- round(n_top)
adj_poss <- round(adj_poss)
#colors for plotting after each timepoint
colors <- rainbow((length(n)-1)*1.25) #times 1.2 so it doesn't loop back around
#get booleans for whether learning and innovation needs to be individually calculated, and scale and center population size
learn_bool <- learn_x_times > 0 | learn_x_pop > 0
innov_bool <- innov_x_times > 0 | innov_x_pop > 0
n_scale <- scale(n)
#initialize starting beta for all agents
beta <- sample(c(TRUE, FALSE), n_holds, prob = c(beta_true_prob, 1-beta_true_prob), replace = TRUE)
#initialize data table of agents
climbers <- data.table::data.table(ID = pop_data$ID[which(pop_data$start == years[1])],
ref_times = pop_data$time[which(pop_data$start == years[1])]/sum(beta),
beta = lapply(1:n[1], function(x){beta}),
seq_ratios = lapply(1:n[1], function(x){truncnorm::rtruncnorm(n_holds, a = 0, mean = 1, sd = sd_multiplier)}),
ath_imp = lapply(1:n[1], function(x){bounded_exp(1:length(n), truncnorm::rtruncnorm(1, a = 1, mean = improve_rate_m, sd = improve_rate_sd), improve_min)}),
current_record = pop_data$time[which(pop_data$start == years[1])])
#create output list
output <- list()
#store the output from initialization
if(sum_stats){output[[1]] <- quantile(climbers$current_record, probs = seq(0, 1, quant_by))}
if(!sum_stats){output[[1]] <- sort(climbers$current_record)}
#initialize plot
if(plot){
par(mar = c(4, 4, 1, 1))
plot(density(climbers$current_record, bw = bw), xlab = "Time (s)", main = "", xlim = c(0, mean(climbers$current_record)), ylim = c(0, ylim))
}
#iterate over time
#for(i in 2:length(n)){
for(i in 2:7){
#get top n climbers for each climber to compare themselves with
top_climbers <- order(climbers$current_record)[1:n_top]
#if needed, calculate the unique learn_prob and innov_prob for each old and new climber in this timestep
t_scale <- scale(climbers$current_record)
if(learn_bool){learn_prob_ind <- sapply(1:nrow(climbers), function(x){inv_logit(logit(learn_prob) + learn_x_times*t_scale[x] + learn_x_pop*n_scale[i])})}
if(innov_bool){innov_prob_ind <- sapply(1:nrow(climbers), function(x){inv_logit(logit(innov_prob) + innov_x_times*t_scale[x] + innov_x_pop*n_scale[i])})}
#get who will learn
if(learn_bool){to_learn <- sapply(1:nrow(climbers), function(x){sample(c(TRUE, FALSE), 1, prob = c(learn_prob_ind[x], 1-learn_prob_ind[x]))})}
if(!learn_bool){to_learn <- sample(c(TRUE, FALSE), nrow(climbers), prob = c(learn_prob, 1-learn_prob), replace = TRUE)}
#for each climber who is sampled
for(k in c(1:nrow(climbers))[which(to_learn)]){
#find out which top climbers have different beta than climber k
diff_top_climbers <- top_climbers[which(sapply(top_climbers, function(x){!identical(climbers$beta[[k]], climbers$beta[[top_climbers[x]]])}))]
#if there are top climbers with different beta
if(length(diff_top_climbers) > 0){
#get possible new times for climber k assuming the beta and seq_ratios of the top climbers with different beta
poss_new_times <- sapply(diff_top_climbers, function(x){sum((climbers$ref_times[x]*climbers$seq_ratios[[x]]*climbers$ath_imp[[x]][i])[climbers$beta[[x]]])})
#if the lowest possible new time is better than the current record, then replace the beta and seq_ratio of climber k with beta from best beta from top climbers
if(min(poss_new_times) < climbers$current_record[k]){
climbers$beta[[k]] <- climbers$beta[[diff_top_climbers[which.min(poss_new_times)]]]
climbers$seq_ratios[[k]] <- climbers$seq_ratios[[diff_top_climbers[which.min(poss_new_times)]]]
}
rm(list = c("poss_new_times"))
}
rm(list = c("diff_top_climbers"))
}
#get who will innovate
if(innov_bool){to_flip <- which(sapply(1:nrow(climbers), function(x){sample(c(TRUE, FALSE), 1, prob = c(innov_prob_ind[x], 1-innov_prob_ind[x]))}))}
if(!innov_bool){to_flip <- which(sample(c(TRUE, FALSE), nrow(climbers), prob = c(innov_prob, 1-innov_prob), replace = TRUE))}
#if individuals are going to change their beta
if(length(to_flip) > 0){
#go through individuals
for(j in to_flip){
#store original beta
beta_a <- climbers$beta[[j]]
seq_ratios_a <- climbers$seq_ratios[[j]]
#if there are any FALSE positions
if(length(which(beta_a == FALSE) > 0)){
#iterate through beta and figure out which positions are okay to flip (do not create strings of FALSE that exceed adj_poss)
ok_holds <- which(sapply(1:length(beta_a), function(x){
#skip starting holds
if(x %in% c(1, 2)){
return(FALSE)
} else{
#make copy of beta_a to test whether position is okay
temp <- beta_a
temp[x] <- !temp[x]
#if the flip doesn't change everything to TRUE (rare case that throws warning)
if(length(which(temp == FALSE) > 0)){
#if the maximum string of FALSEs, assuming this position flips, is less than or equal to adj_poss, then it's okay to flip
if(max(rle(temp)$lengths[which(rle(temp)$values == FALSE)]) <= adj_poss){
return(TRUE)
} else{
return(FALSE)
}
} else{
return(TRUE)
}
#remove temp object
rm(temp)
}
}))
} else{
#everything okay except starting holds
ok_holds <- c(3:n_holds)
}
#make a copy
beta_b <- beta_a
seq_ratios_b <- seq_ratios_a
#choose position to flip
beta_to_flip <- sample(ok_holds, 1)
#flip a position into copied beta
beta_b[beta_to_flip] <- !beta_b[beta_to_flip]
#resample adjacent seq_ratios
seq_ratios_b[ok_holds[which(ok_holds == beta_to_flip)-1]] <- truncnorm::rtruncnorm(1, a = 0, mean = 1, sd = sd_multiplier)
seq_ratios_b[ok_holds[which(ok_holds == beta_to_flip)+1]] <- truncnorm::rtruncnorm(1, a = 0, mean = 1, sd = sd_multiplier)
#decide which is better
sum_a <- sum(seq_ratios_a[beta_a])
sum_b <- sum(seq_ratios_b[beta_b])
#if new one is better, then overwrite current
if(sum_b < sum_a){
climbers$beta[[j]] <- beta_b
climbers$seq_ratios[[j]] <- seq_ratios_b
}
#remove temporary objects
rm(list = c("beta_a", "seq_ratios_a", "ok_holds", "beta_b", "seq_ratios_b", "beta_to_flip", "sum_a", "sum_b"))
}
}
#get indices of climbers whose beta and sequence ratios will be randomly sampled for new climbers
add_inds <- sample(1:nrow(climbers), length(which(pop_data$start == years[i])), replace = TRUE)
#generate data table of new climbers
new_climbers <- data.table::data.table(ID = pop_data$ID[which(pop_data$start == years[i])],
ref_times = pop_data$time[which(pop_data$start == years[i])]/sapply(1:length(climbers$beta[add_inds]), function(x){sum(climbers$beta[add_inds][[x]])}),
beta = climbers$beta[add_inds],
seq_ratios = climbers$seq_ratios[add_inds],
ath_imp = lapply(1:length(which(pop_data$start == years[i])), function(x){bounded_exp(1:length(n), truncnorm::rtruncnorm(1, a = 1, mean = improve_rate_m, sd = improve_rate_sd), improve_min)}),
current_record = pop_data$time[which(pop_data$start == years[i])])
#scale athletic improvement of new climbers to keep them on same trajectory as old climbers
new_climbers$ath_imp <- lapply(1:nrow(new_climbers), function(x){new_climbers$ath_imp[[x]]/new_climbers$ath_imp[[x]][i]})
#simulate leaving the sport
climbers <- climbers[-which(climbers$ID %in% pop_data$ID[which(pop_data$end == years[i-1])]), ]
#store current record of old climbers
climbers$current_record <- sapply(1:nrow(climbers), function(x){sum((climbers$ref_times[x]*climbers$seq_ratios[[x]]*climbers$ath_imp[[x]][i])[climbers$beta[[x]]])})
#combine data tables of old and new climbers
climbers <- data.table::rbindlist(list(climbers, new_climbers))
#plot
if(plot){
lines(density(climbers$current_record, bw = bw)$x, density(climbers$current_record, bw = bw)$y, type = "l", col = colors[i-1])
}
#store the output
if(sum_stats){output[[i]] <- quantile(climbers$current_record, probs = seq(0, 1, quant_by))}
if(!sum_stats){output[[i]] <- sort(climbers$current_record)}
#remove objects
rm(list = c("top_climbers", "add_inds", "new_climbers", "to_learn", "to_flip"))
if(learn_bool){rm(learn_prob_ind)}
if(innov_bool){rm(innov_prob_ind)}
}
i <- 8
top_climbers <- order(climbers$current_record)[1:n_top]
#if needed, calculate the unique learn_prob and innov_prob for each old and new climber in this timestep
t_scale <- scale(climbers$current_record)
if(learn_bool){learn_prob_ind <- sapply(1:nrow(climbers), function(x){inv_logit(logit(learn_prob) + learn_x_times*t_scale[x] + learn_x_pop*n_scale[i])})}
if(innov_bool){innov_prob_ind <- sapply(1:nrow(climbers), function(x){inv_logit(logit(innov_prob) + innov_x_times*t_scale[x] + innov_x_pop*n_scale[i])})}
#get who will learn
if(learn_bool){to_learn <- sapply(1:nrow(climbers), function(x){sample(c(TRUE, FALSE), 1, prob = c(learn_prob_ind[x], 1-learn_prob_ind[x]))})}
if(!learn_bool){to_learn <- sample(c(TRUE, FALSE), nrow(climbers), prob = c(learn_prob, 1-learn_prob), replace = TRUE)}
#for each climber who is sampled
for(k in c(1:nrow(climbers))[which(to_learn)]){
#find out which top climbers have different beta than climber k
diff_top_climbers <- top_climbers[which(sapply(top_climbers, function(x){!identical(climbers$beta[[k]], climbers$beta[[top_climbers[x]]])}))]
#if there are top climbers with different beta
if(length(diff_top_climbers) > 0){
#get possible new times for climber k assuming the beta and seq_ratios of the top climbers with different beta
poss_new_times <- sapply(diff_top_climbers, function(x){sum((climbers$ref_times[x]*climbers$seq_ratios[[x]]*climbers$ath_imp[[x]][i])[climbers$beta[[x]]])})
#if the lowest possible new time is better than the current record, then replace the beta and seq_ratio of climber k with beta from best beta from top climbers
if(min(poss_new_times) < climbers$current_record[k]){
climbers$beta[[k]] <- climbers$beta[[diff_top_climbers[which.min(poss_new_times)]]]
climbers$seq_ratios[[k]] <- climbers$seq_ratios[[diff_top_climbers[which.min(poss_new_times)]]]
}
rm(list = c("poss_new_times"))
}
rm(list = c("diff_top_climbers"))
}
#get who will innovate
if(innov_bool){to_flip <- which(sapply(1:nrow(climbers), function(x){sample(c(TRUE, FALSE), 1, prob = c(innov_prob_ind[x], 1-innov_prob_ind[x]))}))}
if(!innov_bool){to_flip <- which(sample(c(TRUE, FALSE), nrow(climbers), prob = c(innov_prob, 1-innov_prob), replace = TRUE))}
to_flip
j <- 5
#store original beta
beta_a <- climbers$beta[[j]]
seq_ratios_a <- climbers$seq_ratios[[j]]
beta_a
#if there are any FALSE positions
if(length(which(beta_a == FALSE) > 0)){
#iterate through beta and figure out which positions are okay to flip (do not create strings of FALSE that exceed adj_poss)
ok_holds <- which(sapply(1:length(beta_a), function(x){
#skip starting holds
if(x %in% c(1, 2)){
return(FALSE)
} else{
#make copy of beta_a to test whether position is okay
temp <- beta_a
temp[x] <- !temp[x]
#if the flip doesn't change everything to TRUE (rare case that throws warning)
if(length(which(temp == FALSE) > 0)){
#if the maximum string of FALSEs, assuming this position flips, is less than or equal to adj_poss, then it's okay to flip
if(max(rle(temp)$lengths[which(rle(temp)$values == FALSE)]) <= adj_poss){
return(TRUE)
} else{
return(FALSE)
}
} else{
return(TRUE)
}
#remove temp object
rm(temp)
}
}))
} else{
#everything okay except starting holds
ok_holds <- c(3:n_holds)
}
ok_holds
#make a copy
beta_b <- beta_a
seq_ratios_b <- seq_ratios_a
beta_b
beta_b[ok_holds[1]]
beta_b[ok_holds[16]]
beta_b[ok_holds[17]]
beta_b[ok_holds[18]]
beta_b[ok_holds[14]]
beta_b[ok_holds[13]]
beta_b[ok_holds[13]]
beta_b[ok_holds[13]]
beta_b
beta_b[ok_holds]
beta_a
beta_a[x]
beta_a[4]
is.false(beta_a[4])
is.TRUE(beta_a[4])
is.true(beta_a[4])
isFALSE(FALSE)
isFALSE(beta_a[4])
#iterate through beta and figure out which positions are okay to flip (do not create strings of FALSE that exceed adj_poss)
ok_holds <- which(sapply(1:length(beta_a), function(x){
#skip starting holds
if(x %in% c(1, 2)){
return(FALSE)
} else if(isFALSE(beta_a[x])){ #only flip TRUE to FALSE
return(FALSE)
} else{
#make copy of beta_a to test whether position is okay
temp <- beta_a
temp[x] <- !temp[x]
#if the flip doesn't change everything to TRUE (rare case that throws warning)
if(length(which(temp == FALSE) > 0)){
#if the maximum string of FALSEs, assuming this position flips, is less than or equal to adj_poss, then it's okay to flip
if(max(rle(temp)$lengths[which(rle(temp)$values == FALSE)]) <= adj_poss){
return(TRUE)
} else{
return(FALSE)
}
} else{
return(TRUE)
}
#remove temp object
rm(temp)
}
}))
ok_holds
beta_a[ok_holds]
#make a copy
beta_b <- beta_a
seq_ratios_b <- seq_ratios_a
beta_b
seq_ratios_b
beta_b
ok_holds
beta_b[ok_holds[1]]
k <- 1
ok_holds[k]
ok_holds[k]
beta_b
beta_b[1:(ok_holds[k]-1)]
which(beta_b[1:(ok_holds[k]-1)])
max(which(beta_b[1:(ok_holds[k]-1)]))
which(beta_b[(ok_holds[k]+1):(n_holds+1)])
beta_b[(ok_holds[k]+1):(n_holds+1)]
beta_b[(ok_holds[k]+1):(n_holds+1)]
rep(FALSE, ok_holds[k])
c(rep(FALSE, ok_holds[k]), beta_b[(ok_holds[k]+1):(n_holds+1)])
which(c(rep(FALSE, ok_holds[k]), beta_b[(ok_holds[k]+1):(n_holds+1)]))
min(which(c(rep(FALSE, ok_holds[k]), beta_b[(ok_holds[k]+1):(n_holds+1)])))
max(which(beta_b[1:(ok_holds[k]-1)]))
min(which(c(rep(FALSE, ok_holds[k]), beta_b[(ok_holds[k]+1):(n_holds+1)])))
lower_adj <- max(which(beta_b[1:(ok_holds[k]-1)]))
upper_adj <- min(which(c(rep(FALSE, ok_holds[k]), beta_b[(ok_holds[k]+1):(n_holds+1)])))
upper_adj
ok_holds
k <- 12
lower_adj <- max(which(beta_b[1:(ok_holds[k]-1)]))
upper_adj <- min(which(c(rep(FALSE, ok_holds[k]), beta_b[(ok_holds[k]+1):(n_holds+1)])))
lower_adj
beta_b
lower_adj <- max(which(beta_b[1:(ok_holds[k]-1)]))
upper_adj <- min(which(c(rep(FALSE, ok_holds[k]), beta_b[(ok_holds[k]+1):n_holds], TRUE)))
lower_adj
upper_adj
which(c(rep(FALSE, ok_holds[k]), beta_b[(ok_holds[k]+1):n_holds], TRUE))
which(c(rep(FALSE, ok_holds[k]), beta_b[(ok_holds[k]+1):n_holds], TRUE)
)
c(rep(FALSE, ok_holds[k])
)
c(rep(FALSE, ok_holds[k]))
which(beta_b)
ok_holds
beta_b-ok_holds[k]
k
k <- 3
beta_b-ok_holds[k]
ok_holds[k]
beta_b
which(beta_b)-ok_holds[k]
which(c(beta_b, TRUE))-ok_holds[k]
adj_dists <- which(c(rep(FALSE, ok_holds[k]), beta_b[(ok_holds[k]+1):n_holds], TRUE))
adj_dists
adj_dists
which(c(rep(FALSE, ok_holds[k]), beta_b[(ok_holds[k]+1):n_holds], TRUE))
k
which(beta_b)-ok_holds[k]
which(c(beta_b, TRUE)-ok_holds[k]
)
which(c(beta_b, TRUE))-ok_holds[k]
#store adjacent distances (with added TRUE for final buzzer)
adj_dists <- which(c(beta_b, TRUE))-ok_holds[k]
adj_dists
ok_holds[3]
which(adj_dists < 0)
abs(which(adj_dists < 0))
abs(adj_dists[which(adj_dists < 0)])
which.min(abs(adj_dists[which(adj_dists < 0)]))
which.min(abs(adj_dists[which(adj_dists < 0)]))
which.min(adj_dists[which(adj_dists > 0)])
which.min(adj_dists[which(adj_dists > 0)])
which.min(adj_dists[which(adj_dists > 0)])
adj_dists[which(adj_dists > 0)][which.min(adj_dists[which(adj_dists > 0)])]
which.min(adj_dists[which(adj_dists > 0)])
which(adj_dists > 0)[which.min(adj_dists[which(adj_dists > 0)])]
which(adj_dists > 0)[which.min(adj_dists[which(adj_dists > 0)])]
ok_holds[k]
which(adj_dists > 0)[which.min(adj_dists[which(adj_dists > 0)])]
lower_adj
#store adjacent distances (with added TRUE for final buzzer)
adj_dists <- which(c(beta_b, TRUE))-ok_holds[k]
#get used hold below and above
lower_adj <- which.min(abs(adj_dists[which(adj_dists < 0)]))
upper_adj <- which(adj_dists > 0)[which.min(adj_dists[which(adj_dists > 0)])]
lower_adj
upper_adj
grid$x[upper_adj]-grid$x[lower_adj]
(grid$x[upper_adj]-grid$x[lower_adj])^2
(grid$x[upper_adj]-grid$x[lower_adj])^2-(grid$y[upper_adj]-grid$y[lower_adj])^2
sqrt((grid$x[upper_adj]-grid$x[lower_adj])^2-(grid$y[upper_adj]-grid$y[lower_adj])^2)
(grid$x[upper_adj]-grid$x[lower_adj])^2-(grid$y[upper_adj]-grid$y[lower_adj])^2)
(grid$x[upper_adj]-grid$x[lower_adj])^2-(grid$y[upper_adj]-grid$y[lower_adj])^2
(grid$x[upper_adj]-grid$x[lower_adj])^2+(grid$y[upper_adj]-grid$y[lower_adj])^2
sqrt((grid$x[upper_adj]-grid$x[lower_adj])^2+(grid$y[upper_adj]-grid$y[lower_adj])^2)
sqrt((grid$x[upper_adj]-grid$x[lower_adj])^2+(grid$y[upper_adj]-grid$y[lower_adj])^2)
euc_dists <- sapply(1:length(ok_holds), function(x){
#store adjacent distances (with added TRUE for final buzzer)
adj_dists <- which(c(beta_b, TRUE))-ok_holds[k]
#get used hold below and above
lower_adj <- which.min(abs(adj_dists[which(adj_dists < 0)]))
upper_adj <- which(adj_dists > 0)[which.min(adj_dists[which(adj_dists > 0)])]
#return euclidean distance between them
return(sqrt((grid$x[upper_adj]-grid$x[lower_adj])^2+(grid$y[upper_adj]-grid$y[lower_adj])^2))
})
euc_dists
euc_dists <- sapply(1:length(ok_holds), function(x){
#store adjacent distances (with added TRUE for final buzzer)
adj_dists <- which(c(beta_b, TRUE))-ok_holds[x]
#get used hold below and above
lower_adj <- which.min(abs(adj_dists[which(adj_dists < 0)]))
upper_adj <- which(adj_dists > 0)[which.min(adj_dists[which(adj_dists > 0)])]
#return euclidean distance between them
return(sqrt((grid$x[upper_adj]-grid$x[lower_adj])^2+(grid$y[upper_adj]-grid$y[lower_adj])^2))
})
euc_dists
#choose position to flip
beta_to_flip <- sample(ok_holds, 1, prob = euc_dists^constraint)
#flip a position into copied beta
beta_b[beta_to_flip] <- FALSE
beta
beta_a
beta_b
beta_to_flip
seq_ratios_b
ok_holds == beta_to_flip
beta_to_flip
which(c(beta_b, TRUE))-beta_to_flip
which(c(beta_b, TRUE))-beta_to_flip
#make a copy
beta_b <- beta_a
seq_ratios_b <- seq_ratios_a
#get euclidean distances between adjacent holds for each option
euc_dists <- sapply(1:length(ok_holds), function(x){
#store adjacent distances (with added TRUE for final buzzer)
adj_dists <- which(c(beta_b, TRUE))-ok_holds[x]
#get used hold below and above
lower_adj <- which.min(abs(adj_dists[which(adj_dists < 0)]))
upper_adj <- which(adj_dists > 0)[which.min(adj_dists[which(adj_dists > 0)])]
#return euclidean distance between them
return(sqrt((grid$x[upper_adj]-grid$x[lower_adj])^2+(grid$y[upper_adj]-grid$y[lower_adj])^2))
})
beta_b
x <- 1
#store adjacent distances (with added TRUE for final buzzer)
adj_dists <- which(c(beta_b, TRUE))-ok_holds[x]
adj_dists
abs(adj_dists[which(adj_dists < 0)])
abs(adj_dists[which(adj_dists < 0)])
which.min(abs(adj_dists[which(adj_dists < 0)]))
which.min(abs(adj_dists[which(adj_dists < 0)]))
which.min(abs(adj_dists[which(adj_dists < 0)]))
which(c(beta_b, TRUE))
which(c(beta_b, TRUE))[which.min(abs(adj_dists[which(adj_dists < 0)]))]
which(c(beta_b, TRUE))[which.min(abs(adj_dists[which(adj_dists < 0)]))]
ok_holds
x <- 11
#store adjacent distances (with added TRUE for final buzzer)
adj_dists <- which(c(beta_b, TRUE))-ok_holds[x]
adj_dists
beta_b
#get used hold below and above
lower_adj <- which(c(beta_b, TRUE))[which.min(abs(adj_dists[which(adj_dists < 0)]))]
upper_adj <- which(c(beta_b, TRUE))[which(adj_dists > 0)[which.min(adj_dists[which(adj_dists > 0)])]]
lower_adj
upper_adj
return(sqrt((grid$x[upper_adj]-grid$x[lower_adj])^2+(grid$y[upper_adj]-grid$y[lower_adj])^2))
#get euclidean distances between adjacent holds for each option
euc_dists <- sapply(1:length(ok_holds), function(x){
#store adjacent distances (with added TRUE for final buzzer)
adj_dists <- which(c(beta_b, TRUE))-ok_holds[x]
#get used hold below and above
lower_adj <- which(c(beta_b, TRUE))[which.min(abs(adj_dists[which(adj_dists < 0)]))]
upper_adj <- which(c(beta_b, TRUE))[which(adj_dists > 0)[which.min(adj_dists[which(adj_dists > 0)])]]
#return euclidean distance between them
return(sqrt((grid$x[upper_adj]-grid$x[lower_adj])^2+(grid$y[upper_adj]-grid$y[lower_adj])^2))
})
euc_dists
#choose position to flip
beta_to_flip <- sample(ok_holds, 1, prob = (1/euc_dists)^constraint)
beta_to_flip
beta_b
beta_to_flip
#get used hold below and above flipped beta for resampling times
adj_dists <- which(c(beta_b, TRUE))-beta_to_flip
adj_dists
lower_adj <- which(c(beta_b, TRUE))[which.min(abs(adj_dists[which(adj_dists < 0)]))]
upper_adj <- which(c(beta_b, TRUE))[which(adj_dists > 0)[which.min(adj_dists[which(adj_dists > 0)])]]
lower_adj
upper_adj
test <- readRDS("~/Documents/Work/Summer_2021/Speed Climbing/SpeedClimbingABM/hpcc_output/params.RDS")
plot(density(test$constraint))
test <- readRDS("~/Documents/Work/Summer_2021/Speed Climbing/SpeedClimbingABM/hpcc_output/params.RDS")
plot(density(test$constraint))
test <- readRDS("~/Documents/Work/Summer_2021/Speed Climbing/SpeedClimbingABM/hpcc_output/params.RDS")
plot(density(test$constraint))
test <- readRDS("~/Documents/Work/Summer_2021/Speed Climbing/SpeedClimbingABM/hpcc_output/params.RDS")
plot(density(test$constraint))
test <- readRDS("~/Documents/Work/Summer_2021/Speed Climbing/SpeedClimbingABM/hpcc_output/params.RDS")
plot(density(test$constraint))
test <- readRDS("~/Documents/Work/Summer_2021/Speed Climbing/SpeedClimbingABM/hpcc_output/params.RDS")
plot(density(test$constraint))
plot(density(test$innov_prob))
plot(density(test$learn_prob))
plot(density(test$innov_x_pop))
plot(density(test$innov_x_times))
plot(density(test$learn_x_pop))
plot(density(test$learn_x_times))
plot(density(test$n_top))
plot(density(test$improve_rate_m))
plot(density(test$constraint))
test <- readRDS("~/Documents/Work/Summer_2021/Speed Climbing/SpeedClimbingABM/hpcc_output/params.RDS")
plot(density(test$constraint))
test <- readRDS("~/Documents/Work/Summer_2021/Speed Climbing/SpeedClimbingABM/hpcc_output/params.RDS")
plot(density(test$constraint))
test <- readRDS("~/Documents/Work/Summer_2021/Speed Climbing/SpeedClimbingABM/hpcc_output/params.RDS")
plot(density(test$constraint))
